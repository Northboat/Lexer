# Lexer
> 编译原理实验

环境安装及 flex / bison 使用

~~~bash
yay -S flex bison

flex exam.l
gcc -o exam lex.yy.c
./exam

bison -vtdy parser.y
gcc -o parser lex.yy.c y.tab.c y.tab.h
~~~

flex 实现词法分析器，见 lexer 文件夹，识别以下规则

| 单词名称 | 类别码  | 单词名称 | 类别码   | 单词名称 | 类别码 | 单词名称 | 类别码  |
| -------- | ------- | -------- | -------- | -------- | ------ | -------- | ------- |
| 标识符   | IDENFR  | if       | IFTK     | -        | MINU   | =        | ASSIGN  |
| 整数     | INTCON  | else     | ELSETK   | *        | MULT   | ;        | SEMICN  |
| 字符     | CHARCON | do       | DOTK     | /        | DIV    | ,        | COMMA   |
| 字符串   | STRCON  | while    | WHILETK  | <        | LSS    | (        | LPARENT |
| const    | CONSTTK | for      | FORTK    | <=       | LEQ    | )        | RPARENT |
| int      | INTTK   | scanf    | S CANFTK | >        | GRE    | [        | LBRACK  |
| char     | CHARTK  | printf   | PRINTFTK | >=       | GEQ    | ]        | RBRACK  |
| void     | VOIDTK  | return   | RETURNTK | ==       | EQL    | {        | LBRACE  |
| main     | MAINTK  | +        | PLUS     | !=       | NEQ    | }        | RBRACE  |

flex & bison 语法分析器半成品，见 parser 文件夹，要求实现以下文法，一碰到函数就尼玛离谱，文法定义的有问题

注：calc 文件夹下是一个用 flex 和 bison 实现的计算器，即实现识别运算符和数字，将 token 传入 bison 进行文法分析（压栈计算）

- ＜加法运算符＞ ::= +｜-
- ＜乘法运算符＞ ::= *｜/
- ＜关系运算符＞ ::= <｜<=｜>｜>=｜!=｜==
- ＜字母＞  ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
- ＜数字＞  ::= ０｜＜非零数字＞
- ＜非零数字＞ ::= １｜．．．｜９
- ＜字符＞  ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
- ＜字符串＞  ::= "｛十进制编码为32,33,35-126的ASCII字符｝"
- ＜程序＞  ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞
- ＜常量说明＞ ::= const＜常量定义＞;{ const＜常量定义＞;}
- ＜常量定义＞  ::=  int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞} | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}
- ＜无符号整数＞ ::= ＜非零数字＞｛＜数字＞｝| 0
- ＜整数＞    ::= ［＋｜－］＜无符号整数＞
- ＜标识符＞  ::= ＜字母＞｛＜字母＞｜＜数字＞｝
- ＜声明头部＞  ::= int＜标识符＞ |char＜标识符＞
- ＜变量说明＞ ::= ＜变量定义＞;{＜变量定义＞;}
- ＜变量定义＞ ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'){,(＜标识符＞|＜标识符＞'['＜无符号整数＞']' )}
- ＜类型标识符＞   ::= int | char
- ＜有返回值函数定义＞ ::= ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'
- ＜无返回值函数定义＞ ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'
- ＜复合语句＞  ::= ［＜常量说明＞］［＜变量说明＞］＜语句列＞
- ＜参数表＞  ::= ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞
- ＜主函数＞  ::= void main‘(’‘)’ ‘{’＜复合语句＞‘}’
- ＜表达式＞  ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞} 
- ＜项＞   ::= ＜因子＞{＜乘法运算符＞＜因子＞}
- ＜因子＞  ::= ＜标识符＞｜＜标识符＞'['＜表达式＞']'|'('＜表达式＞')'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞    
- ＜语句＞  ::= ＜条件语句＞｜＜循环语句＞| '{'＜语句列＞'}'| ＜有返回值函数调用语句＞; |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜返回语句＞;
- ＜赋值语句＞  ::= ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞
- ＜条件语句＞ ::= if '('＜条件＞')'＜语句＞［else＜语句＞］
- ＜条件＞  ::= ＜表达式＞＜关系运算符＞＜表达式＞ //整型表达式之间才能进行关系运算 ｜＜表达式＞  //表达式为整型，其值为0条件为假，值不为0时条件为真               
- ＜循环语句＞  ::= while '('＜条件＞')'＜语句＞| do＜语句＞while '('＜条件＞')' |for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞
- ＜步长＞::= ＜无符号整数＞ 
- ＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
- ＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
- ＜值参数表＞  ::= ＜表达式＞{,＜表达式＞}｜＜空＞
- ＜语句列＞  ::= ｛＜语句＞｝
- ＜读语句＞  ::= scanf '('＜标识符＞{,＜标识符＞}')'
- ＜写语句＞  ::= printf '(' ＜字符串＞,＜表达式＞ ')'| printf '('＜字符串＞ ')'| printf '('＜表达式＞')'
- ＜返回语句＞  ::= return['('＜表达式＞')']  
